---
title: 位运算
date: 2017-08-15 20:43:38
updated: 2017-08-15 20:43:38
tags: [计算机基础]
categories: 其他
---
- 程序中的所有数在计算机内存中都是以二进制的形式储存的。位运算就是直接对整数在内存中的二进制位进行操作


```
Java 位运算符:

& ：按位与。
| ：按位或。
^ ：按位异或。
~ ：按位取反。
<< ：左位移运算符。
>> ：右位移运算符。
>>> ：无符号右移运算符。

单位换算：
1个二进制数据0或1 = 1bit(位)
1byte（字节） = 8bit
1k = 1024byte(字节)
1M = 1024k
1G = 1024M
1T = 1024G

// 一个英文字符占1个字节
// 一个汉字占2个字节
// 一个int 类型的十进制数占4个字节
```


<!--more-->

#### 一、计算
- 拿两个十进制的数来做例子：
`13转二进制为：1101`
`14转二进制为：1110`

> tip:如果不熟悉二进制可以看我之前的文章

- `&` 按位与
规则：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0，例：
```
	1101
&   1110
-------------
	1100

即：13&14=1100(二进制)= 12（十进制）
```


- `|` 按位或
规则：参加运算的两个数只要两个数中的一个为1，结果就为1
```
	1101
|   1110
-------------
	1111

即：13|14=1111(二进制)= 15（十进制）

```


- `^` 按位异或
规则：参加运算的两个数，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。例：
```
	1101
^   1110
-------------
	0011

即：13^14=0011(二进制)= 3（十进制）

```


- `~` 按位取反
规则：取反的二进制位全部取反,1变为0,0变为1.即
> 这里 引进了3个概念：原码，反码、补码。
> 原码:在数值前面增加了一位符号位（即最高位为符号位）：正数该位为0，负数该位为1,所以第一位表示符号位，其余位表示真值
> 反码:正数的反码与其原码相同；负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.
> 补码:正数的补码与其原码相同； 负数补码为:符号位不变，其绝对值各位取反加1


```
// 我们知道正数的原码 和补码一样，而且在计算机里面存的也是补码
[13的补码]	00001101
~13   
---------------------
			11110010	//取反操作：这个取反出来的是一个补码，我们要求出原码才能转

//如果补码的符号位为“1”，表示是一个负数，求原码的操作可以是：符号位为1，其余各位取反，然后再整个数加1。可得

	反码，最高符号位不变= 10001101
	在+1，可得 			10001110

	最高位为1说明这是一个负数不做计算，真值为：1110=0+2+4+8=14
	所以 ~13 = -14
```

> - 如果补码的符号位为“0”，表示是一个正数，所以补码就是该数的原码。
> - 如果补码的符号位为“1”，表示是一个负数，求原码的操作可以是：符号位为1，其余各位取反，然后再整个数加1。
> - 负数的补码=反码+1
> -负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.



- 在Java中，因为移动规则就是当byte、short、char这三种类型做位移运算的时候自动转换为int型，而int型是32位。所以结果就是按照回32位来的，大于等于32的数是取对32的余数计算。所以位移35位结果等于位移3位。



- `<<` 左位移运算符。
a<<b 规则:将二进制数a整个向左移b位,低位用0补齐,例：
```
// a=13  ,b=3

	 0000 0000 0000 0000 0000 0000 0000 1101
a<<b
-------------
	 0000 0000 0000 0000 0000 0000 0110 1000 

	0+0+0+8+0+32+64+0=104
即：a<<b=13<<3=01101000(二进制)=104（十进制）


```
> 个人结论：其实有个简单的算法，就是左移几位就乘与2的几次方。如上：13*2^3=13*8=104， 如果a为负数，结果也为负数。
> 注意：如果b 大于32时，则对b取模。当b>32时，b=b%32。比如当b=36时，其实只位移了36%32=4位。


- `>>` 右位移运算符。
a>>b 规则: 指将二进制数a整个向右移b位,低位舍弃,例：
```
// a=13  ,b=3

	 0000 0000 0000 0000 0000 0000 0000 1101
a>>b
-------------
	 0000 0000 0000 0000 0000 0000 0000 0001 

即：a>>b=13>>3=00000001(二进制)=1（十进制）




// 是如果是负数，位置不够时 高位需要补1（正数高位补0）
// a=-13  ,b=3
原码： 1000 0000 0000 0000 0000 0000 0000 1101
反码： 1111 1111 1111 1111 1111 1111 1111 0010
补码： 1111 1111 1111 1111 1111 1111 1111 0011

右移3位
补码： 1111 1111 1111 1111 1111 1111 1111 1110  （负数补1）
原码： 1000 0000 0000 0000 0000 0000 0000 0001+1=1000 0000 0000 0000 0000 0000 0000 0010=-2

```

- `>>>` 无符号右移运算符。
a>>>b 规则: 指将二进制数a整个向右移b位,不论正负数，不够补零
```
// a=13  ,b=3

	 0000 0000 0000 0000 0000 0000 0000 1101
a>>b
-------------
	 0000 0000 0000 0000 0000 0000 0000 0001 

即：a>>>b=13>>>3=00000001(二进制)=1（十进制）


//如果是负数
//a =-13,b=3

-13
原码： 1000 0000 0000 0000 0000 0000 0000 1101
反码： 1111 1111 1111 1111 1111 1111 1111 0010
补码： 1111 1111 1111 1111 1111 1111 1111 0011

右移3位
补码： 0001 1111 1111 1111 1111 1111 1111 1110
原码： 0001 1111 1111 1111 1111 1111 1111 1110

结果：0+2^1+2^2+2^3+.....+2^28=Sn
用等比数列求和公式计算就可以得出结果。
Sn=a1(1-q^n)/(1-q)=2*(1-2^28)/(1-2)=536870910

```

