---
title: JVM拆解
date: 2020-08-06 18:44:35
tags: [JVM]
categories: Java
---
### 前言
最近在找些JVM的学习资料，为了以后复习，在此留个笔记。

### 一、JVM是什么
JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。
JVM有自己完善的架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。
我们的Java程序都是在它上面运行的。

### 二、JRE/JDK/JVM/HotSpot 是什么关系
+ JRE(JavaRuntimeEnvironment）
Java运行环境，也就是Java平台。所有的Java 程序都要在JRE下才能运行。普通用户只需要运行已开发好的java程序，安装JRE即可.
+ JDK(Java Development Kit)
是程序开发者用来来编译、调试java程序用的开发工具包。JDK的工具也是Java程序，也需要JRE才能运行。
为了保持JDK的独立性和完整性，在JDK的安装过程中，JRE也是 安装的一部分。所以，在JDK的安装目录下有一个名为jre的目录，用于存放JRE文件。
+ JVM(JavaVirtualMachine)
Java虚拟机是JRE的一部分。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的，总的来说是一种标准规范。虚拟机有很多实现版本
+ HotSpot
HotSpot，顾名思义，它是基于热点代码探测的，是虚拟机的一种实现，它是Sun JDK和OpenJDK中所带的虚拟机,也是目前使用范围最广的Java虚拟机。
> HotSpot VM历史：是由一家名为“Longview Technologies”的小公司设计的； 甚至这个虚拟机最初并非是为Java语言而开发的，它来源于Strongtalk VM， 而这款虚拟机中相当多的技术又是来源于一款支持Self语言实现“达到C语言50%以上的执行效率”的目标而设计的虚拟机， Sun公司注意到了这款虚拟机在JIT编译上有许多优秀的理念和实际效果，在1997年收购了Longview Technologies公司，从而获得了HotSpot VM。
> 在2006年的JavaOne大会上，Sun公司宣布最终会把Java开源，并在随后的一年，陆续将JDK的各个部分（其中当然也包括了HotSpot VM）在GPL协议下公开了源码， 并在此基础上建立了OpenJDK。这样，HotSpot VM便成为了Sun JDK和OpenJDK两个实现极度接近的JDK项目的共同虚拟机。
> 在2008年和2009年，Oracle公司分别收购了BEA公司和Sun公司，这样Oracle就同时拥有了两款优秀的Java虚拟机：JRockit VM和HotSpot VM。 Oracle公司宣布在不久的将来（大约应在发布JDK 8的时候）会完成这两款虚拟机的整合工作，使之优势互补。 整合的方式大致上是在HotSpot的基础上，移植JRockit的优秀特性，譬如使用JRockit的垃圾回收器与MissionControl服务， 使用HotSpot的JIT编译器与混合的运行时系统


### 三、JVM结构
Java 虚拟机的内存空间分为 5 个部分：
+ 程序计数器(PC 寄存器)
+ Java虚拟机栈
+ 本地方法栈
+ 堆
+ 方法区

**每个Java虚拟机都有一个类装载子系统，它根据给定的全限定名来装入类型（类或接口）。同样，每个Java虚拟机都有一个执行引擎，它负责执行那些包含在被装载类的方法中的指令。** 　　


#### 1、JDK1.7
JDK1.7的结构如下：
![](jvm1.7.png)
由图可以看出堆和方法区连在了一起，但这并不能说堆和方法区是一起的，它们在逻辑上依旧是分开的。但在物理上来说，它们又是连续的一块内存。
而堆的组成架构如下：
+ 新生代
	+ eden
	+ From survivor
	+ To survivor
+ 老年代

如图：
![](jvm1.7-heap.jpg)
也就是说，方法区和Eden和老年代是连续的。对于习惯了在HotSpot虚拟机上开发、部署的程序员来说，很多都愿意将方法区称作永久代。
本质上来讲两者并不等价，仅因为Hotspot将GC分代扩展至方法区，或者说使用永久代来实现方法区。在其他虚拟机上是没有永久代的概念的。也就是说方法区是规范，永久代是Hotspot针对该规范进行的实现。
同时，永久代和堆是相互隔离的，但它们使用的物理内存是连续的。永久代的垃圾收集是和老年代捆绑在一起的，因此无论谁满了，都会触发永久代和老年代的垃圾收集。

#### 2、JDK1.8
在Java8中，时代变了，Hotspot取消了永久代。永久代真的成了永久的记忆。永久代的参数-XX:PermSize和-XX：MaxPermSize也随之失效。
虽然取消了永久代，但是方法区还在，因为方法区是虚拟机的一种规范。
Jdk1.8结构图如下：
![](jvm1.8.png)
![](jvm1.8.jpg)
元空间(MetaSpace)存在于本地内存，意味着只要本地内存足够，它不会出现像永久代中“java.lang.OutOfMemoryError: PermGen space”这种错误。
默认情况下元空间是可以无限使用本地内存的。永久代的移除并不意味者类加载器泄露的问题就没有了。
因此，你仍然需要监控你的消费和计划，因为内存泄露会耗尽整个本地内存，导致内存交换(swapping)，这样只会变得更糟，但JVM同样提供了参数来限制它的使用。
+ -XX:MetaspaceSize
class metadata的初始空间配额，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当的降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize（如果设置了的话），适当的提高该值。
+ -XX:MaxMetaspaceSize
可以为 class metadata分配的最大空间。默认是没有限制的
+ -XX:MinMetaspaceFreeRatio
在GC之后，最小的Metaspace剩余空间容量的百分比，减少为class metadata分配空间导致的垃圾收集。
+ -XX:MaxMetaspaceFreeRatio
在GC之后，最大的Metaspace剩余空间容量的百分比，减少为class metadata释放空间导致的垃圾收集

##### 2.1元空间的特点
+ 每个加载器有专门的存储空间。
+ 不会单独回收某个类。
+ 元空间里的对象的位置是固定的。
+ 如果发现某个加载器不再存活了，会把相关的空间整个回收

##### 2.2永久代为什么被替换了？
+ 字符串存在永久代中，容易出现性能问题和内存溢出
+ 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。
+ 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低
+ Oracle 可能会将HotSpot 与 JRockit 合二为一

#### 3、小结
JDK 1.8 同 JDK 1.7 比，最大的差别就是：元数据区取代了永久代。元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。
不过元空间与永久代之间最大的区别在于：元数据空间并不在虚拟机中，而是使用本地内存。

#### 4、程序计数器（PC 寄存器）
+ 定义
程序计数器是一块较小的内存空间，是当前线程正在执行的那条字节码指令的地址，它可以看作是当前线程所执行的字节码的行号指示器。
在Java虚拟机的概念模型里[1]，字节码解释器工作时就是通过改变这个计数器 的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处 理、线程恢复等基础功能都需要依赖这个计数器来完成。
由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一 个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因 此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程 之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。
如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（`Undefined`）。此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何`OutOfMemoryError`情况的区域。
+ 特点
是一块较小的内存空间。
线程私有，每条线程都有自己的程序计数器。
生命周期：随着线程的创建而创建，随着线程的结束而销毁
是唯一一个不会出现`OutOfMemoryError`的内存区域

#### 5、Java 虚拟机栈（Java 栈）
Java 虚拟机栈是描述 Java 方法运行过程的内存模型。	
Java 虚拟机栈会为每一个即将运行的 Java 方法创建一块叫做“栈帧”的区域，用于存放该方法运行过程中的一些信息，如：
+ 局部变量表
+ 操作数栈
+ 动态链接
+ 方法出口信息
+ ...

![](jvm-stack.jpg)
当方法运行过程中需要创建局部变量时，就将局部变量的值存入栈帧中的局部变量表中。
Java 虚拟机栈的栈顶的栈帧是当前正在执行的活动栈，也就是当前正在执行的方法，PC 寄存器也会指向这个地址。只有这个活动的栈帧的本地变量可以被操作数栈使用，当在这个栈帧中调用另一个方法，与之对应的栈帧又会被创建，新创建的栈帧压入栈顶，变为当前的活动栈帧。
方法结束后，当前栈帧被移出，栈帧的返回值变成新的活动栈帧中操作数栈的一个操作数。如果没有返回值，那么新的活动栈帧中操作数栈的操作数没有变化。
> 由于Java 虚拟机栈是与线程对应的，数据不是线程共享的，因此不用关心数据一致性问题，也不会存在同步锁的问题。

**栈的特点：**
+ 局部变量表随着栈帧的创建而创建，它的大小在编译时确定，创建时只需分配事先规定的大小即可。在方法运行过程中，局部变量表的大小不会发生改变
+ Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。
StackOverFlowError 若 Java 虚拟机栈的大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度时，抛出 StackOverFlowError 异常。
OutOfMemoryError 若允许动态扩展，那么当线程请求栈时内存用完了，无法再动态扩展时，抛出 OutOfMemoryError 异常。
+ Java 虚拟机栈也是线程私有，随着线程创建而创建，随着线程的结束而销毁。

#### 6、本地方法栈（C 栈）
+ 定义
本地方法栈是为 JVM 运行 Native 方法准备的空间，由于很多 Native 方法都是用 C 语言实现的，所以它通常又叫 C 栈。它与 Java 虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型。
+ 栈帧变化过程
本地方法被执行时，在本地方法栈也会创建一块栈帧，用于存放该方法的局部变量表、操作数栈、动态链接、方法出口信息等。
方法执行结束后，相应的栈帧也会出栈，并释放内存空间。也会抛出 `StackOverFlowError` 和 `OutOfMemoryError` 异常。

#### 7、堆
**定义**
堆是用来存放对象的内存空间，几乎所有的对象都存储在堆中

**堆的特点：**
+ 线程共享，整个 Java 虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java 虚拟机栈、本地方法栈都是一个线程对应一个。
+ 在虚拟机启动时创建。
+ 是垃圾回收的主要场所。
+ 进一步可分为：新生代(Eden区 From Survior To Survivor)、老年代。

不同的区域存放不同生命周期的对象，这样可以根据不同的区域使用不同的垃圾回收算法，更具有针对性
堆的大小既可以固定也可以扩展，但对于主流的虚拟机，堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已无法再扩展时，就抛出 OutOfMemoryError 异常。
> Java 堆所使用的内存不需要保证是连续的。而由于堆是被所有线程共享的，所以对它的访问需要注意同步问题，方法和对应的属性都需要保证一致性


#### 8、本地内存之方法区
**定义**
Java 虚拟机规范中定义方法区是堆的一个逻辑部分。方法区存放以下信息：
+ 已经被虚拟机加载的类信息
+ 常量
+ 静态变量
+ 即时编译器编译后的代码

**方法区的特点**
+ 线程共享。 方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。
+ 永久代。 方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，把方法区称为“永久代”。
+ 内存回收效率低。 方法区中的信息一般需要长期存在，回收一遍之后可能只有少量信息无效。主要回收目标是：对常量池的回收；对类型的卸载。
+ Java 虚拟机规范对方法区的要求比较宽松。 和堆一样，允许固定大小，也允许动态扩展，还允许不实现垃圾回收。

**运行时常量池**
方法区中存放：类信息、常量、静态变量、即时编译器编译后的代码。常量就存放在运行时常量池中。
.class文件的常量池，也可以理解为一张表，虚拟机指令根据这张常量表找到要执行的类名，方法名，参数类型，字面量等信息
当类被 Java 虚拟机加载后， .class 文件中的常量就存放在方法区的运行时常量池中。而且在运行期间，可以向常量池中添加新的常量。如 String 类的 intern() 方法就能在运行期间向常量池中添加字符串常量。

> 在JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为永久代
> 在JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代
> 在JDK1.8 hotspot移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace) 
> 参考链接：[https://blog.csdn.net/q5706503/article/details/84640762](https://blog.csdn.net/q5706503/article/details/84640762)

#### 9、本地内存之直接内存
直接内存是除 Java 虚拟机之外的内存，但也可能被 Java 使用

**操作直接内存**
在 NIO 中引入了一种基于通道和缓冲的 IO 方式。它可以通过调用本地方法直接分配 Java 虚拟机之外的内存，然后通过一个存储在堆中的DirectByteBuffer对象直接操作该内存，而无须先将外部内存中的数据复制到堆中再进行操作，从而提高了数据操作的效率。

直接内存的大小不受 Java 虚拟机控制，但既然是内存，当内存不足时就会抛出 OutOfMemoryError 异常。

**直接内存与堆内存比较**
+ 直接内存申请空间耗费更高的性能
+ 直接内存读取 IO 的性能要优于普通的堆内存。
+ 直接内存作用链： 本地 IO -> 直接内存 -> 本地 IO
+ 堆内存作用链：本地 IO -> 直接内存 -> 非直接内存 -> 直接内存 -> 本地 IO

### 四、类文件结构
#### 1、JVM 的“无关性”
谈论 JVM 的无关性，主要有以下两个：

+ 平台无关性：任何操作系统都能运行 Java 代码
+ 语言无关性： JVM 能运行除 Java 以外的其他代码
Java 源代码首先需要使用 Javac 编译器编译成 .class 文件，然后由 JVM 执行 .class 文件，从而程序开始运行。

JVM 只认识 .class 文件，它不关心是何种语言生成了 .class 文件，只要 .class 文件符合 JVM 的规范就能运行。 目前已经有 JRuby、Jython、Scala 等语言能够在 JVM 上运行。
它们有各自的语法规则，不过它们的编译器 都能将各自的源码编译成符合 JVM 规范的 .class 文件，从而能够借助 JVM 运行它们。
> Java 语言中的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的， 因此字节码命令所能提供的语义描述能力肯定会比 Java 语言本身更加强大。 因此，有一些 Java 语言本身无法有效支持的语言特性，不代表字节码本身无法有效支持。


#### 2、Class 文件结构
Class 文件是二进制文件，它的内容具有严格的规范，文件中没有任何空格，全都是连续的 0/1。Class 文件 中的所有内容被分为两种类型：无符号数、表。
+ 无符号数 
无符号数表示 Class 文件中的值，这些值没有任何类型，但有不同的长度。u1、u2、u4、u8 分别代表 1/2/4/8 字节的无符号数。
+ 表 
由多个无符号数或者其他表作为数据项构成的复合数据类型。

**Class 文件具体由以下几个构成:**
+ 魔数
+ 版本信息
+ 常量池
+ 访问标志
+ 类索引、父类索引、接口索引集合
+ 字段表集合
+ 方法表集合
+ 属性表集合

![](class.png)

**魔数**
Class 文件的头 4 个字节称为魔数，用来表示这个 Class 文件的类型。
Class 文件的魔数是用 16 进制表示的`CAFE BABE`
> 魔数相当于文件后缀名，只不过后缀名容易被修改，不安全，因此在 Class 文件中标识文件类型比较合适。

**版本信息**

紧接着魔数的 4 个字节是版本信息，5-6 字节表示次版本号，7-8 字节表示主版本号，它们表示当前 Class 文件中使用的是哪个版本的 JDK。

高版本的 JDK 能向下兼容以前版本的 Class 文件，但不能运行以后版本的 Class 文件，即使文件格式并未发生任何变化，虚拟机也必需拒绝执行超过其版本号的 Class 文件。

**常量池**

版本信息之后就是常量池，常量池中存放两种类型的常量：  
+ 字面值常量  
  字面值常量就是我们在程序中定义的字符串、被 final 修饰的值。
+ 符号引用  
  符号引用就是我们定义的各种名字：类和接口的全限定名、字段的名字和描述符、方法的名字和描述符。

**常量池的特点**

+ 常量池中常量数量不固定，因此常量池开头放置一个 u2 类型的无符号数，用来存储当前常量池的容量。
+ 常量池的每一项常量都是一个表，表开始的第一位是一个 u1 类型的标志位（tag），代表当前这个常量属于哪种常量类型。

**常量池中常量类型**

| 类型    | tag   | 描述　|
|---|---|---|
| CONSTANT_utf8_info | 1 | UTF-8编码的字符串 |
| CONSTANT_Integer_info | 3 | 整型字面量 |
| CONSTANT_Float_info | 4 | 浮点型字面量 |
| CONSTANT_Long_info  |5 | 长整型字面量 |
| CONSTANT_Double_info | 6 |  双精度浮点型字面量 |
| CONSTANT_Class_info | 7 |   类或接口的符号引用 |
| CONSTANT_String_info    | 8 |   字符串类型字面量 |
| CONSTANT_Fieldref_info  | 9 |   字段的符号引用 |
| CONSTANT_Methodref_info | 10 |  类中方法的符号引用 |
| CONSTANT_InterfaceMethodref_info    | 11 |  接口中方法的符号引用 |
| CONSTANT_NameAndType_info | 12 |    字段或方法的符号引用 |
| CONSTANT_MethodHandle_info  | 15 |  表示方法句柄 |
| CONSTANT_MethodType_info    | 16 |  标识方法类型 |
| CONSTANT_InvokeDynamic_info | 18 |  表示一个动态方法调用点 |

对于 `CONSTANT_Class_info`（此类型的常量代表一个类或者接口的符号引用），它的二维表结构如下：

| 类型 | 名称 | 数量 |
| --- | --- | --- |
| u1 | tag | 1 |
| u2 | name\_index | 1 |

tag 是标志位，用于区分常量类型；`name_index` 是一个索引值，它指向常量池中一个 `CONSTANT_Utf8_info` 类型常量，此常量代表这个类（或接口）的全限定名，这里 `name_index` 值若为 `0x0002`，也即是指向了常量池中的第二项常量。
`CONSTANT_Utf8_info` 型常量的结构如下：

| 类型 | 名称 | 数量 |
| --- | --- | --- |
| u1 | tag | 1 |
| u2 | length | 1 |
| u1 | bytes | length |

tag 是当前常量的类型；length 表示这个字符串的长度；bytes 是这个字符串的内容（采用缩略的 UTF8 编码）

**访问标志**
在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口；是否定义为 public 类型；是否被 abstract/final 修饰。

**类索引、父类索引、接口索引集合**

类索引和父类索引都是一个 u2 类型的数据，而接口索引集合是一组 u2 类型的数据的集合，Class 文件中由这三项数据来确定类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。

由于 Java 不允许多重继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 Java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。一个类可能实现了多个接口，因此用接口索引集合来描述。这个集合第一项为 u2 类型的数据，表示索引表的容量，接下来就是接口的名字索引。

类索引和父类索引用两个 u2 类型的索引值表示，它们各自指向一个类型为 `CONSTANT_Class_info` 的类描述符常量，通过该常量总的索引值可以找到定义在 `CONSTANT_Utf8_info` 类型的常量中的全限定名字符串。

**字段表集合**

字段表集合存储本类涉及到的成员变量，包括实例变量和类变量，但不包括方法中的局部变量。

每一个字段表只表示一个成员变量，本类中的所有成员变量构成了字段表集合。字段表结构如下：

| 类型 | 名称 | 数量 | 说明 |
| --- | --- | --- | --- |
| u2 | access_flags | 1 | 字段的访问标志，与类稍有不同 |
| u2 | name_index | 1 | 字段名字的索引 |
| u2 | descriptor_index | 1 | 描述符，用于描述字段的数据类型。 基本数据类型用大写字母表示； 对象类型用“L 对象类型的全限定名”表示。 |
| u2 | attributes_count | 1 | 属性表集合的长度 |
| u2 | attributes | attributes_count | 属性表集合，用于存放属性的额外信息，如属性的值。 |

> 字段表集合中不会出现从父类（或接口）中继承而来的字段，但有可能出现原本 Java 代码中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。

**方法表集合**

方法表结构与属性表类似。

volatile 关键字 和 transient 关键字不能修饰方法，所以方法表的访问标志中没有 `ACC_VOLATILE` 和 `ACC_TRANSIENT` 标志。

方法表的属性表集合中有一张 Code 属性表，用于存储当前方法经编译器编译后的字节码指令。

**属性表集合**

每个属性对应一张属性表，属性表的结构如下：

| 类型 | 名称 | 数量 |
| --- | --- | --- |
| u2 | attribute_name_index | 1 |
| u4 | attribute_length | 1 |
| u1 | info | attribute_length |


### 五、类的加载
类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构。
类的加载的最终产品是位于堆区中的 Class对象， Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。
#### 1、类的生命周期
类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括以下 7 个阶段：
+ 加载
+ 验证
+ 准备
+ 解析
+ 初始化
+ 使用
+ 卸载

> 验证、准备、解析 3 个阶段统称为连接。
![](loadclass.png)
加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始（注意是“开始”，而不是“进行”或“完成”），而解析阶段则不一定：它在某些情况下可以在初始化后再开始，这是为了支持 Java 语言的运行时绑定。

**类加载过程中“初始化”开始的时机**
Java 虚拟机规范没有强制约束类加载过程的第一阶段（即：加载）什么时候开始，但对于“初始化”阶段，有着严格的规定。有且仅有 5 种情况必须立即对类进行“初始化”：
+ 在遇到 new、putstatic、getstatic、invokestatic 字节码指令时，如果类尚未初始化，则需要先触发其初始化。
+ 对类进行反射调用时，如果类还没有初始化，则需要先触发其初始化。
+ 初始化一个类时，如果其父类还没有初始化，则需要先初始化父类。
+ 虚拟机启动时，用于需要指定一个包含 main() 方法的主类，虚拟机会先初始化这个主类。
+ 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类还没初始化，则需要先触发其初始化。

**这 5 种场景中的行为称为对一个类进行主动引用，除此之外，其它所有引用类的方式都不会触发初始化，称为被动引用。**

> 对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。

**接口加载过程与类加载过程稍有不同。**
当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，当真正用到父接口的时候才会初始化


#### 2、类的加载过程
类加载过程包括 5 个阶段：加载、验证、准备、解析和初始化。
**加载**
“加载”是“类加载”过程的一个阶段，不能混淆这两个名词。在加载阶段，虚拟机需要完成 3 件事：
+ 通过类的全限定名获取该类的二进制字节流。
+ 将二进制字节流所代表的静态结构转化为方法区的运行时数据结构。
+ 在内存中创建一个代表该类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。

对于 Class 文件，虚拟机没有指明要从哪里获取、怎样获取。除了直接从编译好的 .class 文件中读取，还有以下几种方式：
+ 从 zip 包中读取，如 jar、war等
+ 从网络中获取，如 Applet
+ 通过动态代理技术生成代理类的二进制字节流
+ 由 JSP 文件生成对应的 Class 类
+ 从数据库中读取，如 有些中间件服务器可以选择把程序安装到数据库中来完成程序代码在集群间的分发。

非数组类”与“数组类”加载比较
+ 非数组类加载阶段可以使用系统提供的引导类加载器，也可以由用户自定义的类加载器完成，开发人员可以通过定义自己的类加载器控制字节流的获取方式（如重写一个类加载器的 loadClass() 方法）
+ 数组类本身不通过类加载器创建，它是由 Java 虚拟机直接创建的，再由类加载器创建数组中的元素类。

> 虚拟机规范未规定 Class 对象的存储位置，对于 HotSpot 虚拟机而言，Class 对象比较特殊，它虽然是对象，但存放在方法区中。
> 加载阶段与连接阶段的部分内容交叉进行，加载阶段尚未完成，连接阶段可能已经开始了。但这两个阶段的开始时间仍然保持着固定的先后顺序。

**验证**
验证阶段确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

验证的过程:
+ 文件格式验证 验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理，验证点如下：
	+ 是否以魔数 0XCAFEBABE 开头
	+ 主次版本号是否在当前虚拟机处理范围内
	+ 常量池是否有不被支持的常量类型
	+ 指向常量的索引值是否指向了不存在的常量
	+ CONSTANT_Utf8_info 型的常量是否有不符合 UTF8 编码的数据
	+ ......
+ 元数据验证 对字节码描述信息进行语义分析，确保其符合 Java 语法规范。
+ 字节码验证 本阶段是验证过程中最复杂的一个阶段，是对方法体进行语义分析，保证方法在运行时不会出现危害虚拟机的事件。
+ 符号引用验证 本阶段发生在解析阶段，确保解析正常执行。

**准备**
准备阶段是正式为类变量（或称“静态成员变量”）分配内存并设置初始值的阶段。这些变量（不包括实例变量）所使用的内存都在方法区中进行分配。

初始值“通常情况下”是数据类型的零值（0, null...），假设一个类变量的定义为：`public static int value = 123;`
那么变量 value 在准备阶段过后的初始值为 0 而不是 123，因为这时候尚未开始执行任何 Java 方法。
存在“特殊情况”：如果类字段的字段属性表中存在 ConstantValue 属性，那么在准备阶段 value 就会被初始化为 ConstantValue 属性所指定的值，假设上面类变量 value 的定义变为：`public static final int value = 123;`
那么在准备阶段虚拟机会根据 ConstantValue 的设置将 value 赋值为 123。

**解析**
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

**初始化**
类初始化阶段是类加载过程的最后一步，是执行类构造器 `<clinit>()` 方法的过程。
`<clinit>()` 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static {} 块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的。
静态语句块中只能访问定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但不能访问。如下方代码所示：
```
public class Test {
    static {
        i = 0;  // 给变量赋值可以正常编译通过
        System.out.println(i);  // 这句编译器会提示“非法向前引用”
    }
    static int i = 1;
}
```

`<clinit>()` 方法不需要显式调用父类构造器，虚拟机会保证在子类的 `<clinit>()` 方法执行之前，父类的 `<clinit>()` 方法已经执行完毕。

由于父类的 `<clinit>()` 方法先执行，意味着父类中定义的静态语句块要优先于子类的变量赋值操作。如下方代码所示：
```
static class Parent {
    public static int A = 1;
    static {
        A = 2;
    }
}

static class Sub extends Parent {
    public static int B = A;
}

public static void main(String[] args) {
    System.out.println(Sub.B); // 输出 2
}
```

`<clinit>()` 方法不是必需的，如果一个类没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成 `<clinit>()` 方法。

接口中不能使用静态代码块，但接口也需要通过 `<clinit>()` 方法为接口中定义的静态成员变量显式初始化。但接口与类不同，接口的 `<clinit>()` 方法不需要先执行父类的 `<clinit>()` 方法，只有当父接口中定义的变量使用时，父接口才会初始化。

虚拟机会保证一个类的 `<clinit>()` 方法在多线程环境中被正确加锁、同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 `<clinit>()` 方法。

#### 3、类加载器
**判断类是否相等**
任意一个类，都由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都有一个独立的类名称空间。

因此，比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那么这两个类就必定不相等。

这里的“相等”，包括代表类的 Class 对象的 `equals()` 方法、`isInstance()` 方法的返回结果，也包括使用 `instanceof` 关键字做对象所属关系判定等情况。

**加载器种类**
+ 启动类加载器（Bootstrap ClassLoader）
 负责将存放在 `<JAVA_HOME>\lib` 目录中的，并且能被虚拟机识别的（仅按照文件名识别，如 `rt.jar`，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。
+ 扩展类加载器（Extension ClassLoader）
负责加载 `<JAVA_HOME>\lib\ext` 目录中的所有类库，开发者可以直接使用扩展类加载器。
+ 应用程序类加载器（Application ClassLoader）
 由于这个类加载器是 `ClassLoader` 中的 `getSystemClassLoader()` 方法的返回值，所以一般也称它为“系统类加载器”。它负责加载用户类路径（`classpath`）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。
 
 ![](classloader.png)
 
 应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：
 + 在执行非置信代码之前，自动验证数字签名。
+ 动态地创建符合用户特定需要的定制化构建类。
+ 从特定的场所取得java class，例如数据库中和网络中。

**JVM类加载机制**
+ 全盘负责
当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入
+ 父类委托
先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类
+ 缓存机制
缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效。

#### 4、双亲委派模型
双亲委派模型是描述类加载器之间的层次关系。它要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。
> 父子关系一般不会以继承的关系实现，而是以组合关系来复用父加载器的代码

**工作过程**
果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（找不到所需的类）时，子加载器才会尝试自己去加载。

在 `java.lang.ClassLoader` 中的 `loadClass()` 方法中实现该过程。

**为什么使用双亲委派模型**
像 java.lang.Object 这些存放在 rt.jar 中的类，无论使用哪个类加载器加载，最终都会委派给最顶端的启动类加载器加载，从而使得不同加载器加载的 Object 类都是同一个。

相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为 java.lang.Object 的类，并放在 classpath 下，那么系统将会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无法保证。


### 六、参数详解
|参数|含义|示例|默认|说明|
|:--:|--|--|--|--|
|<div style="width:200px">-Xms</div>|<div style="width:80px">初始堆大小</div>|<div style="width:150px">-Xms1g</div>|<div style="width:150px">物理内存的1/64(<1GB)</div>|此设置控制Java 堆的初始大小。正确调整此参数有助于降低垃圾回收开销，从而缩短服务器响应时间并提高吞吐量。对于某些应用程序来说，此选项的缺省设置可能会太低，从而导致发生大量小型垃圾回收。.|
|-Xmx|最大堆大小|-Xmx1g|物理内存的1/4(<1GB)|此设置控制 Java 堆的最大大小。正确调整此参数有助于降低垃圾回收开销，从而缩短服务器响应时间并提高吞吐量。对于某些应用程序来说，此选项的缺省设置可能会太低，从而导致发生大量小型垃圾回收。|
|-Xmn|年轻代大小|-Xmn512m|物理内存的1/4(<1GB)|注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8|
|-XX:NewRatio|年轻代与年老代的比值|-XX:NewRatio=1||-XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5 Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。|
|-XX:SurvivorRatio|Eden区与Survivor区的大小比值||默认8:1:1 |设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10|
|-Xss |每个线程的堆栈大小|||DK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.更具应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右,一般小的应用， 如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。|
|-XX:MetaspaceSize |初始元数据空间大小|-XX:MetaspaceSize=256m|-XX:MetaspaceSize=21807104（bit=20.79M），我通过`jinfo -flag MetaspaceSize PID`命令得到的|是指Metaspace扩容时触发FullGC的初始化阈值，也是最小的阈值。|
|-XX:MaxMetaspaceSize |元数据空间最大值|-XX:MaxMetaspaceSize=256m|如果没有使用-XX:MaxMetaspaceSize来设置类的元数据的大小，默认是没有限制的，其最大可利用空间是整个系统内存的可用空间|如果类元数据的空间占用达到MaxMetaspaceSize设置的值，将会触发对象和类加载器的垃圾回收。表示的是保证committed的内存不会超过这个值，一旦超过这个值就会触发GC。|
|-XX:MinMetaspaceFreeRatio |元数据最小的空闲比例|-XX:MinMetaspaceFreeRatio=30|40|当进行过Metaspace GC之后，会计算当前Metaspace的空闲空间比，如果空闲比小于这个参数，那么虚拟机将增长Metaspace的大小。在本机该参数的默认值为40，也就是40%。设置该参数可以控制Metaspace的增长的速度，太小的值会导致Metaspace增长的缓慢，Metaspace的使用逐渐趋于饱和，可能会影响之后类的加载。而太大的值会导致Metaspace增长的过快，浪费内存。|
|-XX:MaxMetaspaceFreeRatio |元数据最大的空闲比例|-XX:MaxMetaspaceFreeRatio=70|70|当进行过Metaspace GC之后， 会计算当前Metaspace的空闲空间比，如果空闲比大于这个参数，那么虚拟机会释放Metaspace的部分空间。在本机该参数的默认值为70，也就是70%|
|-XX:MinMetaspaceExpansion |元数据最小增长幅度|-XX:MaxMetaspaceFreeRatio=339968||Metaspace增长时的最小幅度。在本机上该参数的默认值为339968B（大约332KB）|
|-XX:MaxMetaspaceExpansion |元数据最大增长幅度|-XX:MaxMetaspaceFreeRatio=5451776||Metaspace增长时的最大幅度。在本机上该参数的默认值为5451776B（大约540KB）|




> 参考链接：
[https://doocs.gitee.io/jvm/#/docs/01-jvm-memory-structure](https://doocs.gitee.io/jvm/#/docs/01-jvm-memory-structure)
[https://www.choupangxia.com/2019/10/22/interview-jvm-gc-02/](https://www.choupangxia.com/2019/10/22/interview-jvm-gc-02/)
