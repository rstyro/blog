---
title: 乐观锁重试机制代码实现
date: 2019-03-08 18:26:03
tags: [干货]
categories: Java
---

## 乐观锁重试机制代码实现
> 有乐观锁，那当然也是有悲观锁的

### 悲观锁和乐观锁的原理和应用场景
#### 悲观锁(Pessimistic Lock)
**顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。**

#### 乐观锁(Optimistic Lock)
**顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁**

### 应用场景
#### 悲观锁：
**比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。**
#### 乐观锁：
**比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。**

## 总结：两种所各有优缺点，读取频繁使用乐观锁，写入频繁使用悲观锁。


## 代码实现原理
这里采用版本号的方式

### 简单例子表结构
|字段名称|类型|字段描述|
|--|--|--|
|id|long|主键ID|
|user_id|long|用户ID|
|balance|decimal|用户余额|
|version|long|乐观锁版本号|
|modify_time|datetime|更新时间|
|create_time|datetime|创建时间|



比如现在表中有两条数据
|id|user_id|balance|version|modfy_time|create_time|
|--|--|--|--|--|--|
|1|1001|100|1|2019-03-08 12:00:00|2019-03-08 12:00:00|
|2|1002|100|1|2019-03-08 12:00:00|2019-03-08 12:00:00|

现在 `user_id = 1001` 给 `user_id=1002` 转账 `50` 元
### 流程如下

为了方便，这里我抽出一个方法
```
	
	/**
	 * 更新 用户账户余额
	 * @param userId 用户ID
	 * @param amount    转账金额
	 * @param state     1-- 转入，0 -- 转出
	 * @throws Exception
	 */
	public void updateAccount(Long userId,BigDecimal amount,int state) throws Exception {
		//通过UserId,获取用户账户
		UserAccount userAccount = getAccountByUserId(userId);
		if (state == 1) {
			// 转入，则加余额
			userAccount.setBalance(userAccount.getBalance().add(amount));
		} else {
			//判断余额是否 满足
			if(userAccount.getBalance().compareTo(amount) < 0 ){
				throw  new Exception("余额不足");
			}
			// 转出，则减余额
			userAccount.setBalance(userAccount.getAmount().subtract(amount));
		}
		//更改更新时间
		userAccount.setModifyTime(LocalDateTime.now());

		// 更新数据库账户信息
		/**
		 *  SQL 语句如下：
		 *  从语句就可以知道 version 的作用了。当版本不对的时候更新失败
		 *  update user_account set balance = #{balance},modify_time=#{modifyTime},version = version+1 where user_id=#{userId} and version=#{version}
		 */
		 if(!this.updateById(userAccount)){
			throw new Exception("交易失败");
		 }
		 System.out.println("========更新成功============");
	}


	//转账
	@Transactional
    public void transfer() throws Exception{
        BigDecimal amount = new BigDecimal("50");
        updateAccount(1001,amount,0);
        updateAccount(1002, amount, 1);
        System.out.println("========交易成功============");

    }

```
### 上面比较重要的是更新的 SQL 语句
#### 如果看懂下面这个语句，就知道什么是乐观锁了，非常简单
```
update user_account set balance = #{balance},modify_time=#{modifyTime},version = version+1 where user_id=#{userId} and version=#{version}
```
> 注意：当数据表有一个写锁时，其它进程的读写操作都需等待读锁释放后才会执行。所以保证了`version` 的正确性

如果交易成功的话，数据会变成如下
|id|user_id|balance|version|modfy_time|create_time|
|--|--|--|--|--|--|
|1|1001|100|2|2019-03-08 13:00:00|2019-03-08 12:00:00|
|2|1002|100|2|2019-03-08 13:00:00|2019-03-08 12:00:00|

也就是 `version` 会比原来的值 大。每次更新都会变，通过这样来实现乐观锁


### 总结：上面更新账户，如果更新失败就会抛异常，这样用户体验不是非常好，所以就有了重试机制

### 1、重试原理，利用到AOP 切片，然后通过 @Around 进行方法增强。
为了方便，创建一个自定义注解，在需要重试的方法上添加 注解即可

##### IsTryAgain
重试注解
```
/**
 * 重试注解
 */
@Retention(RetentionPolicy.RUNTIME)
public @interface IsTryAgain {
}
```

##### TryAgainException
重试异常
```
public class TryAgainException extends RuntimeException {

}
```

##### TryAgainAspect
```
**
 * 更新失败，尝试重试切片
 * @author  rstyro
 */
@Aspect
@Configuration
public class TryAgainAspect {

	/**
	 * 默认重试几次
	 */
	private static final int    DEFAULT_MAX_RETRIES = 3;

	private int                 maxRetries          = DEFAULT_MAX_RETRIES;
	private int                 order               = 1;

	public void setMaxRetries(int maxRetries) {
		this.maxRetries = maxRetries;
	}

	public int getOrder() {
		return this.order;
	}

	@Pointcut("@annotation(IsTryAgain)")
	public void retryOnOptFailure() {
		System.out.println("这里就是切入点了");
	}

	/**
	* 这里就是你要处理的方法了
	*/
	@Around("retryOnOptFailure()")
	public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable {
		int numAttempts = 0;
		do {
			// 重试次数 +1
			numAttempts++;
			try {
				//继续执行 业务代码
				return pjp.proceed();
			} catch (TryAgainException ex) {
				// 这里要注意了，我这里catch 的Exception 是我自己定义的异常（TryAgainException），再才会重试，如果不是的话是不会走这里的
				if (numAttempts > maxRetries) {
					// 如果失败次数 大于最大重试的次数，那就不重试了，直接往外抛
					throw new ApiException(ApiResponMessage.ERROR_SERVER,null);
				}else{
					//如果重试次数小于 最大重试次数，则继续
					System.out.println("=====正在重试=====");
				}
			}
		} while (numAttempts <= this.maxRetries);

		return null;
	}
}
```

#### 准备工作都写好了，就可以继续改造代码

```
	
	/**
	 * 更新 用户账户余额
	 * @param userId 用户ID
	 * @param amount    转账金额
	 * @param state     1-- 转入，0 -- 转出
	 * @throws Exception
	 */
	@IsTryAgain
	@Transactional
	public void updateAccount(Long userId,BigDecimal amount,int state) throws Exception {
		//通过UserId,获取用户账户
		UserAccount userAccount = getAccountByUserId(userId);
		if (state == 1) {
			// 转入，则加余额
			userAccount.setBalance(userAccount.getBalance().add(amount));
		} else {
			//判断余额是否 满足
			if(userAccount.getBalance().compareTo(amount) < 0 ){
				throw  new Exception("余额不足");
			}
			// 转出，则减余额
			userAccount.setBalance(userAccount.getAmount().subtract(amount));
		}
		//更改更新时间
		userAccount.setModifyTime(LocalDateTime.now());

		// 更新数据库账户信息
		/**
		 *  SQL 语句如下：
		 *  从语句就可以知道 version 的作用了。当版本不对的时候更新失败
		 *  update user_account set balance = #{balance},modify_time=#{modifyTime},version = version+1 where user_id=#{userId} and version=#{version}
		 */
		 if(!this.updateById(userAccount)){
			//这里就会重试
			throw new TryAgainException("交易失败");
		 }
		System.out.println("========更新成功============");
	}


	//转账
	@Transactional
    public void transfer() throws Exception{
        BigDecimal amount = new BigDecimal("50");
        updateAccount(1001,amount,0);
        updateAccount(1002, amount, 1);
        System.out.println("========交易成功============");

    }

```

### 其实一点也不难，如果对AOP 熟悉的话。
