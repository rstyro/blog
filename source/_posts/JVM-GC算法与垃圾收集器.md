---
title: JVM-GC算法与垃圾收集器
date: 2020-08-10 15:21:25
tags: [JVM]
categories: Java
---
### 一、什么是垃圾回收
简单的说垃圾回收就是回收内存中不再使用的对象。回收的步骤：
+ 查找内存中不再使用的对象
+ 释放这些对象占用的内存

### 二、判断对象存活
如何判断哪些对象不再使用？有两种方法：
+ 引用计数法
每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。这种方法的缺点就是无法解决对象相互循环引用的问题。
+ 可达性分析(根搜索算法)
基本思路就是通过一系列名为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。
在Java语言中，GC Roots包括：
+ 虚拟机栈(栈帧中的本地变量表)中引用的对象
+ 方法去中类静态属性引用的对象
+ 方法区中常量引用的对象
+ 本地方法栈中JNI(即一般说的Native方法)引用的对象
+ 活跃线程的引用对象

### 三、垃圾回收算法
既然已经知道了垃圾对象，该如何回收呢？算法如下：
+ 标记-清除算法
最基础的收集算法是“标记-清除”(Mark-Sweep)算法，分两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。
**不足：**一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能导致以后在程序运行过程需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一个的垃圾收集动作。
+ 复制算法
为了解决效率问题，一种称为复制(Copying)的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完了，就将还存活着的对象复制到另外一块上，然后再把已经使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。代价是内存缩小为原来的一半。

商业虚拟机用这个回收算法来回收新生代。IBM研究表明98%的对象是“朝生夕死“，不需要按照1-1的比例来划分内存空间，而是将内存分为一块较大的”Eden“空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活的对象一次性复制到另外一个Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。Hotspot虚拟机默认Eden和Survivor的比例是8-1.即每次可用整个新生代的90%, 只有一个survivor，即1/10被”浪费“。当然，98%的对象回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够时，需要依赖其他内存(老年代)进行分配担保(Handle Promotion).
如果另外一块survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。
**Eden survivor复制过程概述**
Eden Space字面意思是伊甸园，对象被创建的时候首先放到这个区域，进行垃圾回收后，不能被回收的对象被放入到空的survivor区域。
Survivor Space幸存者区，用于保存在eden space内存区域中经过垃圾回收后没有被回收的对象。Survivor有两个，分别为To Survivor、 From Survivor，这个两个区域的空间大小是一样的。执行垃圾回收的时候Eden区域不能被回收的对象被放入到空的survivor（也就是To Survivor，同时Eden区域的内存会在垃圾回收的过程中全部释放），另一个survivor（即From Survivor）里不能被回收的对象也会被放入这个survivor（即To Survivor），然后To Survivor 和 From Survivor的标记会互换，始终保证一个survivor是空的。
为啥需要两个survivor？因为需要一个完整的空间来复制过来。当满的时候晋升。每次都往标记为to的里面放，然后互换，这时from已经被清空，可以当作to了。
+ 标记-整理算法
有标记-整理算法些文章也叫标记-压缩算法。
复制收集算法在对象成活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以，老年代一般不能直接选用这种算法。
根据老年代的特点，有人提出一种”标记-整理“Mark-Compact算法，标记过程仍然和标记-清除一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理端边界以外的内存.
图片如下：
![](标记整理算法.png)
+ 分代收集算法
上面算法的组合拳，按照对象生命周期的不同划分区域以采用不同的垃圾回收算法。
一般把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代，每次垃圾收集时都发现大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率较高，没有额外的空间对它进行分配担保，就必须使用”标记-清理“和”标记-整理“算法来进行回收。

### 四、垃圾收集器
如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现
+ Serial 收集器
标记-复制
Serial 翻译为串行，也就是说它以串行的方式执行。
它是单线程的收集器，只会使用一个线程进行垃圾收集工作，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。它是 Client 场景下的默认新生代收集器。
+  ParNew 收集器
ParNew是Serial收集器的多线程版本。Server模式下默认新生代收集器，除了Serial收集器之外，只有它能与CMS收集器配合工作。
+ Parallel Scavenge 收集器
Parallel Scavenge 收集器是一个新生代收集器，它也是使用复制算法的收集器.
Parallel Scavenge 收集器的特点是它的关注点与其他收集器不同，CMS等收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间。而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量(Throughput)。所谓吞吐量就是CPU用于运行用户代码的时间和CPU总小号时间的比值，即吞吐量 = 运行用户代码时间 / (运行用户代码时间+垃圾收集时间)，虚拟机总共运行了100min，其中垃圾收集花费了1min，那吞吐量就是99%。
Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间 `-XX:MaxGCPauseMillis`以及直接设置吞吐量大小的`-XX:GCTimeRatio`.
+ Serial Old收集器
Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器。给Client模式下的虚拟机使用。
新生代采用复制算法，暂停所有用户线程。
老年代采用标记-整理算法，暂停所有用户线程。
+ Parallel Old 收集器
是 Parallel Scavenge 收集器的老年代版本。在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。
+ CMS 收集器
CMS(Concurrent Mark Sweep) 收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类尤其重视服务的响应速度，希望系统停顿时间最短。CMS收集器就非常符合这类应用的需求。
CMS基于 标记-清除算法实现，整个过程步骤：
	+ 初始标记：stop-the-world
	+ 并发标记：并发追溯标记，程序不会停顿
	+ 并发预清理：查找执行并发标记阶段从年轻代晋升到老年代的对象
	+ 重新标记：暂停虚拟机，扫描CMS堆中的剩余对象（stop-the-world）
	+ 并发清理：清理垃圾对象，程序不会停顿
	+ 并发重置：重置CMS收集器的数据结构
CMS特点：并发收集，低停顿。
**缺点：**
	+ CMS收集器对CPU资源非常敏感。默认启动的回收线程数是(CPU+3)/4. 当CPU 4个以上时，并发回收垃圾收集线程不少于25%的CPU资源。
	+ CMS收集器无法处理浮动垃圾（由于CMS并发清理时，用户线程还在运行，伴随产生新垃圾，而这一部分出现在标记之后，只能下次GC时再清理。这一部分垃圾就称为”浮动垃圾“）
	+ CMS基于 标记-清除算法实现，会产生大量空间碎片（当然可以开启-XX:+UseCMSCompactAtFullCollection(默认开)，在CMS顶不住要FullGC时开启内存碎片合并整理过程。内存整理过程是无法并发的，空间碎片问题没了，但停顿时间变长。）。

> 面试题：CMS一共会有几次STW?
> 首先，回答两次，初始标记和重新标记需要。CMS并发的代价是预留空间给用户，预留不足的时候触发FullGC，这时Serail Old会STW
> CMS是标记-清除算法，导致空间碎片，则没有连续空间分配大对象时，FUllGC, 而FUllGC会开始碎片整理，STW。即2次或多次。

+ G1收集器
G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。
堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。
G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。
不过，这些区域的一部分包含新生代，新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间。老年代也分成很多区域，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有cms内存碎片问题的存在了。

在G1中，还有一种特殊的区域，叫Humongous区域。 如果一个对象占用的空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象。这些巨型对象，默认直接会被分配在年老代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC。

### 五、GC的分类
+ Minor GC
发生在年轻代（对象出生的地方，该区域的对象几乎都是“朝生夕灭”）中的GC动作，采用的收集算法是复制（需要复制的对象很少）
+ Full GC
主要对老年代（该区域的对象是“幸存”下来的对象，一般不会再轻易“死亡”）的回收，但同时包含了对年轻代的回收（即包含了Minor GC）。采用的收集算法是标记-清除和标记-整理。相比Minor GC慢，执行频率低。


**年轻代(Young Generation)**
尽可能快速地收集掉那些生命周期短的对象
+ Eden（伊甸园）区
	+ 1.正常情况对象刚被创建出来的时候在eden区，当eden区内存不足时会放到Survivor区，对象很大时会放入老年代
	+ 2.发生Minor GC后有用对象年龄+1并被放入到Suvivor区 
	+ 3.Eden默认占年轻代8的权重，Survivor区两空间分别占1
+ 两个Survivor区（from、to）
发生Minor GC后有用对象年龄+1，并将存活对象从From使用复制算法到To中，清空From空间，当对象年龄达到一定值后进入老年区（默认15）

**老年代(Old Generation)**
存放多次gc后存活的和一些比较大的对象
+ 经历一定Minor GC次数后依然存活的对象
+ Survivor区中存放不下的对象
+ 新生成的大对象（-XX:+PretenuerSizeThreshold）


**触发Full GC的条件**
+ 老年代空间不足
+ 永久代空间不足（JDK1.8之前）
+ CMS GC时出现promotion failed，concurrent mode failure
+ Minor GC晋升到老年代的平均大小大于老年代的剩余空间
+ 调用System.gc()（仅是通知，不保证何时执行）
+ 使用RMI进行PRC调用或管理的JDK应用，每小时执行此Full GC

